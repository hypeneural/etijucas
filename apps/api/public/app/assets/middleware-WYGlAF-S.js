function R(l,v){let r;try{r=l()}catch{return}return{getItem:s=>{var e;const c=d=>d===null?null:JSON.parse(d,void 0),i=(e=r.getItem(s))!=null?e:null;return i instanceof Promise?i.then(c):c(i)},setItem:(s,e)=>r.setItem(s,JSON.stringify(e,void 0)),removeItem:s=>r.removeItem(s)}}const _=l=>v=>{try{const r=l(v);return r instanceof Promise?r:{then(n){return _(n)(r)},catch(n){return this}}}catch(r){return{then(n){return this},catch(n){return _(n)(r)}}}},F=(l,v)=>(r,n,s)=>{let e={storage:R(()=>window.localStorage),partialize:t=>t,version:0,merge:(t,f)=>({...f,...t}),...v},c=!1,i=0;const d=new Set,y=new Set;let u=e.storage;if(!u)return l((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),r(...t)},n,s);const p=()=>{const t=e.partialize({...n()});return u.setItem(e.name,{state:t,version:e.version})},H=s.setState;s.setState=(t,f)=>(H(t,f),p());const h=l((...t)=>(r(...t),p()),n,s);s.getInitialState=()=>h;let m;const b=()=>{var t,f;if(!u)return;const S=++i;c=!1,d.forEach(o=>{var a;return o((a=n())!=null?a:h)});const g=((f=e.onRehydrateStorage)==null?void 0:f.call(e,(t=n())!=null?t:h))||void 0;return _(u.getItem.bind(u))(e.name).then(o=>{if(o)if(typeof o.version=="number"&&o.version!==e.version){if(e.migrate){const a=e.migrate(o.state,o.version);return a instanceof Promise?a.then(I=>[!0,I]):[!0,a]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,o.state];return[!1,void 0]}).then(o=>{var a;if(S!==i)return;const[I,w]=o;if(m=e.merge(w,(a=n())!=null?a:h),r(m,!0),I)return p()}).then(()=>{S===i&&(g?.(m,void 0),m=n(),c=!0,y.forEach(o=>o(m)))}).catch(o=>{S===i&&g?.(void 0,o)})};return s.persist={setOptions:t=>{e={...e,...t},t.storage&&(u=t.storage)},clearStorage:()=>{u?.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>b(),hasHydrated:()=>c,onHydrate:t=>(d.add(t),()=>{d.delete(t)}),onFinishHydration:t=>(y.add(t),()=>{y.delete(t)})},e.skipHydration||b(),m||h},J=F;export{J as p};
